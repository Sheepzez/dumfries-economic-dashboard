
\documentclass{l3proj}

\usepackage{wrapfig}

\begin{document}

\title{Team Project(H) Dissertation: Team A}

\author{Lewis Dicks - 2085749 \\
        Isaac Jordan - 2080466 \\
        Praxitelis (Branko) Kourtellos - 2060408 \\
        Christos (Takis) Nicolaides - 2084564  \\
        Rostislav Yordanov - 2074214 \\
        Michael Byars - 2028262}

\date{\today}

\maketitle

\begin{abstract}

For the first time at the University of Glasgow, the team project undertaken in the third year of a Computing Science
degree involves a real life customer, where previously students undertook projects for individuals lecturers in the
department. This was also the first year in which the Team Project was combined with the Professional Software
Development course as previously students were involved in two team projects, this is now one team with one project that
incorporates techniques learned from the Professional Software Development course. Students worked with institutions
based in the Dumfries and Galloway area of Scotland, such as the Crichton Regional Observatory, the NHS and the third
sector. For our team's project, the team were asked to create an interactive dashboard of various economic indicators that
would be integrated into the Crichton's homepage. This paper presents a case study of the nature of our project and
reflects on our experiences relating to software engineering practices and principles.

\end{abstract}

%% Comment out this line if you do not wish to give consent for your
%% work to be distributed in electronic format.
\educationalconsent

\newpage

%==============================================================================
\section{Introduction}
\label{sec:introduction}

%% Purpose of the document
This project report covers a 7 month University of Glasgow third year project. It is a case study reporting on the aims of the project, the software development process adopted throughout development, the evolution of the software produced, and the evaluation and reflection of the group and project.

%% Very brief outline of the project
The team was asked to create an interactive dashboard of various economic indicators of the Dumfries and Galloway region. The idea behind this project was to provide an easy-to-access and instant visualisation of key economic data that allows businesses, individuals, and prospective investors to gain a snapshot of the current state of the regional economy very easily, without hours of research tracking down potentially obscure documents.

Several key requirements of the final product that were identified included minimising clicks to get to an overview of information, having more detailed information available for those who needed it, and the dashboard should be viable to be managed by non-technical administrative personnel.

The dashboard was built using the Python-based Django~\cite{Django} framework as the team had previous university experience building web applications using this so it was relatively straightforward to begin developing the initial components of the back-end of the website. In addition to this the team used many JavaScript-based front end technologies such as Angular JS~\cite{AngularWebpage}, d3~\cite{d3Webpage} and Gridster~\cite{AngularGridster}. The system architecture is discussed in more detail in Section \ref{sec:system-implementation}.

%% Summary of the rest of the document
The following pages attempt to comprehensively cover all aspects of the development of the dashboard including technical and non-technical issues. Section \ref{sec:background} presents background information on the project, and Section \ref{sec:team-dynamics} to Section \ref{sec:customer-management} cover a range of topics in detail. Finally, some key conclusions are drawn regarding the experience in Section \ref{sec:conclusions}.

%==============================================================================
\section{Case Study Background}
\label{sec:background}

For the first time the Level 3 Team Projects have been commissioned by real life customers, with real problems and requirements. In this first year of the scheme the Crichton Institute~\cite{CrichtonInstitute} has played a major role by offering 6 separate projects for teams to work on, including the dashboard project that our team took on.

% Background on the Crichton Institute, Regional Observatory, and our contacts

The Crichton Institute was launched by the Cabinet Secretary for Education and Lifelong Learning, Michael Russel MSP in January 2013~\cite{CrichtonInsituteFounded} with the aim of bringing together academic and business parters, local government, and regional development bodies in a joint effort to improve southern Scotland in several key areas including: ``the rural economy and skills development, community development and placemaking, the impacts of demographic change and influencing policy and practice''~\cite{CrichtonInsituteCoreAims}. The institute aims to drive overall development of the region and improve it's ability to attract resources and inward investment~\cite{CrichtonInstituteAboutUs}.

In June 2014 the Crichton Institute launched a Regional Observatory~\cite{CrichtonInstituteRegionalObservatory}. The Regional Observatory is a ``web-based information and knowledge portal that acts as a one-stop open-access service for public data, information and intelligence about a wide range of social, economic, and environmental factors across Dumfries and Galloway and the South of Scotland''~\cite{ScotGovOpenDataResourcePack}. This aims to improve the resources of rural areas such as Dumfries and Galloway in terms of data gathering, access, and usage. The Regional Observatory also aims to provide a collaborative base of data and information from a variety of sources which is accessible to all~\cite{ScotGovOpenDataResourcePack}.

The client contacts the team interacted with were Development Officer Eva Milroy~\cite{EvaMilroyLinkedIn}, and Director Tony Fitzpatrick~\cite{TonyFitzpatrickLinkedIn}. Eva Milroy is a key member in setting up and continued running of the Crichton Institute Regional Observatory, as well as providing business intelligence, and developing employer engagement with the Crichton Institute. Tony Fitzpatrick has been director of the Crichton Institute Regional Observatory since it's inception. These two representatives were the team's main contact within the Crichton Institute, and they provided invaluable feedback and insight into the project and problem domain.

% Their problem description

The Regional Observatory provides open access to a large amount of data and reports on a variety of key economic indicators including population, housing, education, and crime. This information is summarised on the Regional Observatory site in text form~\cite{PopulationHealthReport}, however, there are no consistent visualisations of the data, nor the ability to get an overview of the region as a whole without consulting a considerable amount of specific data. This is the problem domain that the team took on to solve.

The team was presented with the idea of creating a regional dashboard which would provide quick access to an intuitive overview of the socioeconomic situation of the Dumfries and Galloway region. This dashboard would be publicly available to any and all interested parties looking for information on the region. The dashboard would contain visualisations of data relevant to Dumfries and Galloway, and comparisons to significant regions such as Scotland-wide. It would also contain links to the relevant sources of the data, so that users can ``drill down'' into the data they are most interested in.

The project also consisted of implementing a ``cheat sheet'' system. The customers wanted their users to be able to create a summary of the economic indicators most important to that specific user, and download it as a PDF document. The exact nature of this system was open to discussion between the developers and the customers.

The customers provided examples of similar socioeconomic dashboards for other regions. One such dashboard was the London Datastore Dashboard~\cite{LondonDashboard} which provides constantly updated information and data on the London area. The key features of the London Dashboard is that a large variety of datasets (over 640 separate datasets) are available, and on the homepage it provides easy to understand line charts on all aspects of the region. Users can view further information by clicking on a specific data category which presents more detailed graphs.

Another dashboard used as an example was the Dublin Dashboard~\cite{DublinDashboard}. This dashboard provides a wide variety of information and distinct visualisations on the Dublin area, but the customers commented on how many clicks are required for a user to reach any actual information as the Dublin Dashboard homepage contains no information or visualisations, simply a list of links to other parts of the site. The team quickly recognised a lack of immediately-accessible information as a potential pitfall of our own dashboard, and were careful to note this as an important non-functional requirement.

% What the team initially agreed compared to what the team delivered at the end

Of all the requirements the team initially agreed upon with the customers, the vast majority of them were addressed and either completed as initially suggested or an alternative has been put in place by the end of the development period. The only large initially discussed task the team did not complete is building our own API, but it was concluded with Eva and Tony during a meeting that this was not necessary anyway and because there were a lot of issues concerning availability of data, it would be extremely difficult and the team could use the time the team would have spent working on that more effectively, improving other more important parts of the site.

The customers have been consistently happy throughout, and they did not ask us at any point to remove something the team had done, except for aesthetic details such as shadowing behind text. They made various suggestions during the meetings but even most of those were ideas that the team had already thought about but were yet to implement.

Overall the final product fits the initial brief almost exactly and the customer is happy that what the team have produced meets their requirements. That is, after all, the most important thing.

%==============================================================================
\section{Team Dynamics}
\label{sec:team-dynamics}

The assignment of members to project teams was randomised and sorted based on degree discipline, with our team being Computing Science oriented. Our team members were randomly assigned, however two of us were existing friends and two other members were from the same foreign country which helped with initial team cohesion. One of our first tasks was to add one another on Facebook as a means of team communication, however in addition to this the team also used Slack, a cloud-based team collaboration tool.

The team found Slack to be a much better communication tool than Facebook due to the organisation of discussion groups (e.g. one for general communication, one for minutes of meetings). A version control system was introduced and set up before any development began, so the team was also able to integrate Jenkins and SVN into Slack in order to monitor the success of project builds and also to monitor when new commits are made to the repository. This was very beneficial as it provided a very convenient way for all team members to stay up to date on the latest project progress. This notification system was only introduced several months after initial development started - in hindsight, the team wished that this build notification integration system was known about earlier as it helped drive discussion around each commit.

At the early stages the team also organised team roles: Lewis as Project Manager; Isaac as Technical Lead; Michael as Client Liason; Ross as Retrospective Manager and Branko and Takis were general Software Development Engineers. In terms of agreement of these roles they were unanimous based on the personal traits of each team member and this was consistently adhered to throughout the project. All members were expected to be involved in development, even if their team role did not explicitly include ``software development''.

One particular observation the team noticed early on in the process was the commitment of team members to team meetings and also to efforts made in developing the project. The university had timetabled one all day lab session per week that was dedicated to team project work, and on these days the team had the majority of our team members attend. The problems seemed to arise when team members did not show up for additional team meetings arranged well in advance, sometimes this was due to mitigating circumstances such as ill health or part-time job commitments, and whilst this was acceptable the main issue was the fact that at this stage team members seemed to give no prior notice that they would not be available and consequently only half the team showed up to these meetings on average. As the process continued the consistency of team members attending these extra meetings improved albeit if they showed up later than initially arranged.

In terms of effort put into the project, there seemed to be a pattern where it was only our Tech Lead that was committing the most work into the project in the initial stages. This was down to the fact that he has professional web development experience from previous years while the rest of the team have limited experience. However once the site was partially functioning as a proof of concept, it encouraged more team members to make contributions to the project. Another identified cause of this trend was that in the early stages of the project, much of the work was setting up the overall system architecture (such as the interactions between Django and AngularJS mentioned in Section \ref{sec:system-implementation:system-architecture}). In later iterations there were many tasks that could be developed concurrently - this improved overall team contributions towards the end. However, there was still major issues with uneven contribution levels.

%==============================================================================

\section{System Implementation}
\label{sec:system-implementation}

In software engineering there are many ways to implement a project but there are certain tools that are more advantageous than others. Some tools will allow faster iteration cycles by increasing automation, reducing boilerplate code, or faster prototyping. Other types of tools can help drive code quality improvements by providing code quality metrics such as code coverage analysis in testing, documentation coverage analysis, and warning of unused code. These tools are invaluable in modern software development and were used in this software project. This section focuses on the specific system implementation, and the tools used throughout.

\subsection{System Architecture}
\label{sec:system-implementation:system-architecture}

For this project the team were asked to build a web application, so in order to begin development the team had to decide on a web framework that could be used as the basis of our project. The team chose the Python-based Django web framework~\cite{Django}, as every member of the team had previous experience in developing web applications using this as part of a previous university course. There were discussions around using an alternative framework such as Java Spring and whilst the team were all proficient in the use of Java, there was a unanimous agreement that using a more familiar framework would result in faster development of a system where the requirements could change week-to-week - although not all team members were equally familiar with Django, potentially resulting in an exacerbation of the contribution problem mentioned in Section \ref{sec:team-dynamics}.

Django was not the only Model-View-Controller (MVC) framework used in the project though - the team wanted to learn new skills as well as refining existing ones. It was decided to be appropriate to introduce AngularJS~\cite{AngularWebpage} (a JavaScript MVC framework) into the project. Use of a front-end framework such as AngularJS gave us much greater control over the flow of data in our application while reducing the amount of boilerplate (repeated, menial) code in our JavaScript files. This was also a good learning experience for the team as no team members had any previous experience in using the framework.

The resulting architecture was very interesting to work with. The server-side Django code worked to supply necessary static files to clients (such as the JavaScript code files and images) as well as managing the flow of data to and from the persistent SQL database. The Django middleware worked to mediate the relationship between the AngularJS code running on client machines, and the SQL database on the server.

Many of the interactions between Django and the AngularJS code were accomplished using a technique known as ``Asynchronous JavaScript and XML'' (AJAX). This technique was popularised in 2005~\cite{ANewApproachToWebApplications, W3CAjaxProposal} as a method of creating highly interactive webpages that allow for pieces of information to be sent and retrieved from a client's browser without a full reload the webpage. In this project AJAX was heavily used to retrieve information such as HTML snippets as templates, as well as a wide variety of data in JavaScript Object Notation (JSON) format. This allowed the dashboard to be created with a very interactive feel - information could be loaded on demand when required, as well as sent for validation and storage all while being invisible to the end-user.

Several other tools were used during development of the project. These included the Bootstrap CSS framework~\cite{Bootstrap} which was used to dramatically reduce the amount of CSS code that was required to be written for the desired styling and formatting of the dashboard. D3 (Data-Driven Documents)~\cite{d3Webpage} is a JavaScript library which allows for dynamic generation of SVG elements in HTML from data. This library was used to generate all the line and bar graphs on the dashboard - the high degree of flexibility with D3 is crucial to the extensibility of the dashboard as it allows for an extremely wide variety of visualisations to be added at later stages without modification to other regions of code. Only the D3 code that renders the graphs needs to be modified.

Angular-Gridster~\cite{AngularGridster} is an open-source project which allows for extremely easy integration of Gridster-like features into an AngularJS-based project. Gridster~\cite{Gridster} is a jQuery plugin that allows for an intuitive drag-and-drop multi-column grid experience. Angular-Gridster allowed us to incorporate this functionality into the dashboard with minimal code using Angular directives (keyword shortcuts to add functionality to HTML elements). This drag-and-drop experience became a core feature of our dashboard as it allowed for a very high degree of customisation from a user point-of-view since users could resize, move, delete, and add widgets containing graphs and information to the dashboard.

\section{Development}
\label{sec:development}

The starting point of our project was to create a base template for the site: the team started from an initial Bootstrap template that was a good starting point in terms of colour scheme and layout that was both simplistic yet professional. It provided a simple but functional sidebar that was similar to our initial wireframe designs, and was also mobile responsive - something that wasn't an explicit requirement of the project, but was kept in mind throughout the development process.

\subsection{Iteration One}
\label{sec:development:iteration-one}

The first iteration contained four main tasks that the team wanted to accomplish by the first customer demonstration. These were all major tasks that the team wished to have roughly implemented to demonstrate the direction the team wanted to take the project. The first was to set up some basic version of the customisable dashboard by having what the team called at this stage ``draggable modules'', which are square sections that the user could drag-and-drop around to customise the dashboard. This task was initially created using ng-sortable~\cite{NGSortable}, but this library was found to be unsuitable for the level of customisation the team desired, further research revealed Angular-Gridster to be an ideal choice for the project. The second task was to create some initial D3 graphs to display inside of the draggable modules.

These two tasks were critical to investigate and implement early on, as if the technologies the team had chosen to use did not support this functionality the team would have to investigate new software libraries, or redesign our site. The third task was to build a basic form of what the team wanted the architecture of the project to be like - this involved setting up the Django back-end, and interfacing with an AngularJS client-side. This was important to execute early on to reduce the amount of refactoring that would need to done in later iterations.

The fourth task was to research useful sources of data for our dashboard. This involved an email conversation with our customer, as well as significant amount of online research. This task was never really finished as this process continued on throughout all iterations.

\subsection{Iteration Two}
\label{sec:development:iteration-Two}

The main goal of the second iteration was to add saved configurations. As the customisability of our dashboard was paramount to the design the team had created, it was critical that users could save the layout they had created across multiple sessions. This effectively involved serialising all information pertaining to the layout of the dashboard (e.g. which graph does this module contain, what is it's position, how large is it). This task involved implementing user authentication in the form of a register and login system, as well as creating pages to list a user's saved configuration with matching AJAX calls to load in requested configurations and save new ones.

Another goal of this iteration was to create a script to parse CSV files, create a JSON structure, and store it in the SQL database via Django's ORM (Object Relational Mapping)~\cite{DjangoORM}. This initially small task helped drive design in later iterations to make CSV parsing a major aspect of our project. Several bugs introduced in the previous iteration were also resolved, for example large modules could obscure small ones as the small modules did not automatically move out of the way on the dashboard.

\subsection{Iteration Three}
\label{sec:development:iteration-three}

The third iteration contained a wide variety of tasks. One major concern at this point was the performance of the dashboard. In order to keep the graphs updated, they must be redrawn when the modules change size. Initially this was accomplished by attaching the graph redraw function to the module's on-resize event handler. This was causing hundreds of redraws every second that modules were being manipulated, causing the dashboard to be near unusable when it contained many graphs (or graphs that involved a large number of data points). This issue was resolved this iteration by only redrawing the graphs when the user has finished resizing a module, resulting in only one redraw of the graphs. After making this modification, there were no more performance related problems.

A major task this iteration was the implementation of a CSV Import software module. This would allow administrators to upload CSV files in any format, specify what data they want extracted, and create the relevant database entries to display the data as a graph on the dashboard. This system would greatly improve the versatility of our project since a non-technical administrator could keep the data and graphs up to date. The task was split in several sections in order to be more manageable: allow administrators to upload CSV files, allow administrators to define what data to be extracted, actually process the CSV file and create necessary database entries. This allowed progress to be monitored easier over several weeks.

Another task this iteration was a major refactoring of the back-end system. The initial Django project did not follow Django conventions in terms of project structure, it contained no Django applications. This was resolved at this stage by splitting the project into 4 separate Django apps. The ``dashboard'' app contained all the JavaScript code, as well as views and templates. It contained models which were directly applicable the dashboard such as saved configurations, and layout information. The ``dataset\_importer'' app contained abstract models to be used by the three other apps, such as the definition of a ``Dataset'' and an ``Importer''. The other two apps were designed to cover the two different types of data importer our application would use: CSV files, and API endpoints. An initial implementation of the CSV Importer was finished during this iteration, but the API Importer proved much harder than expected due to data acquisition problems, this issue is discussed more thoroughly in Section \ref{sec:data-acquisition}.

Several other tasks were involved in this iteration including the creation of a population script for continuous integration as discussed in Section \ref{sec:continuous-integration}, and creation of a ``Data Categories'' list page.

\subsection{Iteration Four}
\label{sec:development:iteration-four}

The fourth iteration contained a large number of tickets (20 in total). Several major tasks were undertaken this iteration such as the implementation of a search bar, improving test code coverage from ~50\% to ~100\%, fixing labels on the dashboard's graphs, adding removed graphs back into the dashboard, improving the usability of the administration interface, adding functionality to export the dashboard to PDF, finishing the Data Categories pages started in the previous iteration, and implementing a CSS style switcher in an attempt to improve the dashboard's visual accessibility (larger text, colour-blind friendly colours). Only this last task was not fully accomplished during the iteration. Overall this iteration was extremely successful as many tickets were resolved, and goals met.

\subsection{Iteration Five}
\label{sec:development:iteration-five}

The fifth iteration contained the largest number of tickets of any iteration (31 including the generation of this report). Many of these tickets were small features that were carried from iteration to iteration. One such example is the generation of saved configurations from the results of a search, this feature was not critical but created as a ``if the team have time'' user story. For this particular example, the team did not have time to complete it by the end of the development time.

Our customer was extremely happy with the progress of our project so far, and requested the team not implement any new major features - as a result, the biggest goal for this iteration was to improve stability of the dashboard, add documentation, and attempt to improve code quality. An example of this was to remove several arbitrary timeout values in the JavaScript code. These were added in previous iterations as work-arounds for rare race conditions in the AJAX requests. This iteration these timeouts were removed by properly waiting for these asynchronous events to occur before continuing.

One major issue raised by the client was the ease of use of the website. Since this website was meant to be used by people with different skill sets the team decided to add helpful guides and documentation for both the users and the administrators. On the left bar on the main page of the website a ``Help/Documentation'' link was added which redirects the user to a clear and easy to understand tutorial explaining all of the key features of the website and how to use them. Correspondingly, on the administration panel two links were added to guide the administrators through general management of the dashboard as well as a guide on the specifics of importing CSV data.

Initially the plan was to have a number of different types of graphs, however, the data which was acquired was mainly time series (meaning it monitored a particular value as it changed over time). Therefore the team decided to mainly implement line graphs since they display that type of data most effectively. A few sample bar graphs were added later on for demonstration purposes. Potentially many more types of graphs could have been added, however, the team decided to invest that time on higher priority issues.

One of the last major issues addressed by the team was the graphical visualisation of data on the dashboard. The progress of the project reached to a point where the dashboard provided almost all the required functionalities, so the team decided to give an emphasis on the data visualisation in order to make the dashboard easy to use and user friendly. D3 is a framework that provides many different functions to the developer, it allows to work on the flexibility of the graphs and the visualisation on the same time. Tooltip functionality was added to show the exact values (x and y coordinates) when a user passed their mouse over a particular data point. Bar graphs had particular bars highlighted when the user passed their mouse over a specific bar, this was designed to make longer bars easier to follow horizontally. Care was also given to cases where there might only be a single data point available for the user's chosen date range - in this case, a single large point is shown on the graph that shows the particular value.

%==============================================================================
\section{Agile Software Development Engineering}
\label {sec:core-practices}

Throughout the development of the project the team were also following a course named Professional Software Development. The course's aim was to introduce the students to modern software development methods and techniques for building and maintaining large systems and apply those techniques in a project. One of the methods that was taught was the agile practice. Agile software development ``is a set of principles for software development in which requirements and solutions evolve through collaboration between self-organizing, cross-functional teams. It promotes adaptive planning, evolutionary development, early delivery, and continuous improvement, and it encourages rapid and flexible response to change''~\cite{AgileMethods}.

The agile method that was mostly used was Extreme Programming (XP). The benefits of XP are that it focuses on customer satisfaction, enables the continuous elicitation of requirements from the customers and insists on teamwork both between the team members and the customers. Also, XP improves the communication, simplicity, feedback, respect and courage of the team. It focuses on a number of simple rules that can be easily adhered to~\cite{ExtremeProgramming}.

\begin{wrapfigure}{L}{0.5\textwidth}
\includegraphics[width=1.1\linewidth]{figures/Extreme_Programming}
\caption{Time span of tasks in Extreme Programming.}
\label{fig:extreme-programming}
\end{wrapfigure}

Following the guidelines of XP the team conducted the project with these principles in mind. Since the project was set to finish at a specific date the team set a number of task deadlines which were due at the end of each iteration. In total five iterations (including the final demonstration) have been set by the university~\cite{Planning}. The first iteration was our initial meeting with the customers. From this point the team have understood the concept of the project, gathered initial functional and non-functional requirements of the project and also proposed some ideas to our clients. At the end of the meeting the requirements were translated into user stories, from where a number of tasks have been created to provide possible solutions to the user stories. By the end of this iteration a meeting with the customers was arranged in order to demonstrate the current structure of the project, asking it fits their needs and collect new requirements for the following iterations. This process has been followed until the end of the project including the final demonstration. It is also fair to say that in between each of the iterations the team aimed to discover defects which in turn were translated into new user stories and fixed during their respective iteration, if not the following.

The first step the team took was to maintain a good relationship with their customers. During the meetings and iterations, the relationship between the customer and the team was very close, friendly and completely understanding. The two parties kept in touch at least once or twice during each of the iterations and the team have always asked for their customers' opinion whenever something had to be done that could affect the agreed requirements. The customers were not just sources of information and guidance, instead they were an active member in the team and have very efficiently helped in the development of the project~\cite{Customers}.

During every iteration the team followed a planning method. Since the first meeting has been concluded there have been generated a series of user stories. Those user stories have been carefully examined and graded by the team and have been assigned into specific milestones, i.e. end dates, based on their grade. In addition to that, the clients were informed about these dates and they were informed of what would be finished in the next iteration. Although the user stories were graded and set to specific milestone, they were not fixed, instead they were dynamically changed based on the work done so far, random implications that have risen and the addition of new user stories. Furthermore, every user story had its respective owner(s) who were responsible for the research and development of the story~\cite{UserStories}. In relation to the planning methods, every requirement's milestone set, was after research of the estimated time that can take including external factors such as sickness/assignments/travelling abroad.


%==============================================================================
\section{Process Improvements}
\label{sec:process-improvements}

As part of the project, the university wanted the team to use three tools throughout the process: Subversion (SVN)~\cite{SVN} for our version control repository, Trac~\cite{Trac} as our ticket management system, and Jenkins~\cite{Jenkins} for project builds. Before the start of the project the team had been shown using tutorials how to set these up which was helpful for the long run. The team found SVN relatively straightforward to use in terms of making commits to the repository, however the team would have preferred using Git~\cite{Git} as the team have all had previous experience using this and in general seems much more of a user-friendly experience. Trac was very helpful in terms of monitoring existing tasks that required work upon, and also the use of Wiki pages allowed for better team organisation such as project information and summarising retrospectives. To begin with Jenkins was mostly used for ensuring that builds of the project after commits were successful, however at this point the team did not have much testing on our site. The team also had an issue whereby each time a commit was made to the repository, it would take just over three minutes to build each time as the virtual environment had to be re created every single time. Thankfully the team were able to reduce the build time by changing the point at which the virtual environment is created in the build script. Further into the project the team also integrated Django-Jenkins, a small Django application that runs Python unit tests and generates Jenkins-friendly test results using Junit XML files for test results and Cobertura~\cite{Cobertura} for code coverage. This was extremely helpful in terms of the depth of existing code coverage and what areas were still to be tested.

As part of agile development, the team undertook a retrospective at the end of each iteration~\cite{Retrospectives}. The goals of retrospectives are to establish where the team has done well and identify process improvements for future iterations. A retrospective is started by asking each team member to write their thoughts on how they've felt about the previous iteration on post-it notes. The team divided these into four categories: Liked (things the team liked); Learned (things the team have learned); Lacked (things the team have been doing but could be done better) and Longed For (something that's desired or wished for). Once each team member has written their thoughts down, the Retrospective Manager (Ross) asks each team member in turn what they said for each category by placing their post-it note on a wall or board in order to collate them. By doing this, the team is able to find common opinions whilst also finding thoughts that other team members previously did not consider. To conclude a retrospective, the team summarises the points made i.e. how much have the team progressed as a team and where are the problem areas. From this, the team is able to establish new goals and objectives for the next iteration which may involve creating new tickets on Trac. At the next team meeting, the team clarifies what tasks need done over the next few weeks before the next customer meeting.

Retrospectives were great for the team in terms of finding process improvements. In the first iteration it was more to do with individual efforts such as showing up to team meetings on time, more commits to the repository and clarification of who is working on which tickets. Later iterations had more productive changes due such as more test cases, code documentation and better ticket management. The most useful improvement the team has made in the scope of the project is referencing tickets in commits to the repository: whilst this happened later on in the process, it enabled team members to identify clearly who is working on which tasks and the progress made towards it.

%------------------------------------------------------------------------------

\section{Continuous Integration and Testing}
\label{sec:continuous-integration}

Continuous Integration (CI) is a development practice that requires software developers to integrate code into a shared repository (e.g. using GIT or subversion) several times a day. Every check-in is then verified by an automated build, allowing teams to detect problems early. By integrating regularly, you can detect errors quickly, locate them more easily and solve the problems faster. CI has been adopted as part of the Extreme Programming (XP) development methodology~\cite{ContinuousIntegration}. Since the team adopted the XP method for the project it was only natural for the team to follow the CI practices.

The first practice of CI is about using a shared code repository. As stated in the previous sections the team has used Apache Subversion (a version control system) that helped the team to share and manage their code very easily. Every team member could update to the latest version of the project, then work on their own versions of code changing it as necessary and then were able to commit their changes in order for everyone to be up to date.

Another facet of CI rests upon automating the build, have it build fast, be self tested and automate its deployment. The team has used an automation server called Jenkins and a test server to host the web application of the project. By using Jenkins the team has resolved the issues of automating the build process (with the help of a Python build population script). It has also provided a way of self testing, since as the project was growing tests have been implemented to test the project code, and Jenkins made sure the tests passed before building and updating the live test site. When Jenkins finishes the build and its testing it deployed to a live test server so everyone (both the team members and the clients) could see and evaluate the results.

Furthermore, CI specifies that the developers of the project should commit at least once a day and that commit should be built as soon as is committed. That is a practice that was not followed. Since the team was composed by students such a practice was difficult to follow. As a professional developer it is fairly easy to commit every single day since you have the time required to do so. In the case of a student, even if he split his working time to every single day, the job done would be minimal or even incomplete,causing the the servers to fail. Also, because of the nature of our project a big amount of time was spent on researching for methods or libraries to counter some problems, and that is not a commit material. For these reasons, the commits were inconsistent and every commit would contain a lot of new code from its previous version, which sometimes resulted into merge conflicts which were very difficult to resolve. In order to counter or limit the frequency of conflicts the team managers has suggested the team to be meeting twice a week and also work on the weekends while everyone would inform on what they were working and their commit messages would tell what and which files were changed. The ideas were indeed beneficial and have reduced substantially the counters of conflicts and defects.

Another major issue the team identified was the lack of code testing. As the team were working on implementing various features into the website the team realized that the team have produced a lot of code but if it were to malfunction the team would not be certain where the problem has occurred. Having as high test code coverage as possible benefits the developers in many ways. Big changes can be made to the code and if the test cases still work that indicates that everything is still working properly. Testing code gives you further understanding of design of the code. Now the team had to write unit tests to an already existing code which proved difficult. In order for test cases to be written one has to understand the code which is being tested. And when several people have contributed to that code it is certain that there will be pieces of code which will be inexplicable.

Good teamwork and communication helped the team reach a high percentage of test code coverage. Since the team decided to use the Django framework for our website, which is based on Python the team had to look into Python unit testing. Unfortunately the majority of the team did not have a lot of prior experience with unit testing in Django. Therefore more time had to be invested in developing the needed skills. The team shared online tutorials with one another thus maximising the results as quickly and as efficiently as possible.

%------------------------------------------------------------------------------

\section{Project Planning and Estimation}
\label{sec:planning}

Over the course of a software project, the functional and non-functional requirements identified at the start of the project are liable to change. This can be in the form of modifications to existing requirements, introduction of new requirements, and removal of existing requirements.

In this project only the first two cases occurred - there was no removal of identified requirements at any stage. This was likely due to very thorough discussions with the customer at regular intervals. At the end of each iteration a customer meeting was arranged. This meeting aimed to cover the previous iteration's progress, identify issues, and suggest the direction of the next iteration. At all 5 customer meetings these aims were taken very seriously, as missing any of them could mean weeks of development work in the wrong direction.

At these customer meetings the team attempted to provide estimations of how much progress could be completed by the next meeting. The team believed this was very useful for the customer, as the team could set their expectations well in advance of beginning that iteration's development. These estimations were useful for the team as even the generation of estimations helped to define the goals of the coming weeks. Team members could bring up in advance any issues such as too much work for a specific iteration. In the later iterations this practice became less rigid, and the team identified with the customer was the most critical features were and work on those first. When these critical features were completed team members could move on to less urgent work.

Initially the team attempted to assign story points to each user story. Story points are a standard method of estimating how much time a particular feature may take to implement. However, the team found that initial story point estimations could easily be wildly invalid. With longer iteration cycles of around 1 month, and many team members working on features they had no experience implementing before, the story point method was dropped. This was not a problem for most iterations as constant communication meant all team members were aware of the stage of each ticket, but later iterations were somewhat hectic as many tickets of unknown size had piled up over time.

Several user stories were left uncompleted at the end of the project, but the team had anticipated this early on so it was not unexpected. A major user story that was dropped was the implementation of the API Importer module. This module would automatically retrieve new data at regular intervals from a given external API endpoint. This was not implemented due to two major reasons, the first was issues with finding relevant data that was available via an API endpoint that was also regularly updated as dicussed more in Section \ref{sec:data-acquisition}. The second reason was the complexity of the API structures the team came across. It was anticipated that there would be many APIs using JSON-formatted results, however many actually used technologies such as SPARQL (SPARQL Protocol and RDF Query Language)~\cite{W3SPARQL} which was unexpectedly complex to work with.

Another feature which was not fully completed due to technical limitations was PDF exporting of the dashboard. This feature was working in Iteration Four, but due to the way the graphs were extracted from the webpage the quality of the graphs was rather low. This feature simply required too much time investment to be fully completed by the end of the project.

Other features identified as not being fully finished were not completed as they were too low priority, and did not receive required development time. One such feature was improved accessibility for the visually impaired: much investigative and experimental work was done on this feature, but it was not usable by the end of the project. This is partly due to a lack of initial research into existing solutions to the problem which likely would have reduced the time investment the user story required. In the end, a CSS-style switcher was implemented that could change text size and colour scheme on the dashboard - however due to time constraints the feature was left semi-completed.


%------------------------------------------------------------------------------

\section{Data Acquisition}
\label{sec:data-acquisition}

In order for this project to work the team had to acquire real data to populate the graphs with. The information required was non-personal and non-commercially sensitive. In February 2015 the Scottish Government launched its Open Data Strategy which seeks to make exactly that type of information available for use by all~\cite{ScotGovOpenDataResourcePack}. This strategy adopts the G8 Open Data Principles: Open Data by Default, Quality and Quantity, Usable by All, Releasing Data for improved Governance and Releasing Data for innovation. That means that the team did not have to get specific permission to post any acquired data which was to be used in the website.

The team started by researching the various websites suggested by our customer such as NOMIS Scotland~\cite{NOMISScot}. The team found that most of these sites were difficult to use in terms of extracting exactly the kind of data that the team needed. Eventually the team came across Statistics.Gov.Scot Beta~\cite{StatisticsScotBeta} which was a site being set up on behalf of the Scottish Government to be used as a centralised access point to information. In this, the team were able to find data on many economic indicators in CSV format.

The team created a script that would process these files, extract only the data collected on Dumfries and Galloway and Scotland and format this to be rendered by the d3 code that visualises the data before storing it on our site's database. This data extracting script was implemented into the project by creating a simple population script which used the data extraction method to provide the project with the real data and in parallel to that created fake dummy data for testing purposes (I need help rephrasing this sentence).This was a major step in our project in terms of using real data, however our main issue here was that the data was static, and at the time of download was outdated.

In addition to this the files all used inconsistent date formats (e.g. one would be quarterly, another would be monthly, another yearly) which presented a major issue in terms of a key requirement being that users want to access the latest available data as well as looking back on previous years. The team raised this issue with our customers and they were aware of this issue beforehand, this was a relief. Later on in the development process the team decided to make changes to the data extracting script which was initially created. At first the script was only capable of extracting data from CSV formatted files which strictly modified to fit the same structure. Although this was working at first the team decided to improve the script to be able to extract data from all CSV files regardless of the inner format and structure.

The team decided to keep the old converter script for demonstration purposes while the new one was being developed. The idea behind the new script was to allow administrators to add more CSV files as data sources through a relatively simple process. This process is thoroughly described in the administration panel with examples for quick and easy understanding. Once the new script was fully developed and tested the team implemented it fully into the project thus removing the obsolete old version.

%------------------------------------------------------------------------------

\section{Customer Management}
\label{sec:customer-management}

One of, if not the most important aspect of a successful software development process is the interaction and relationship between the customer and the developers. The best way to ensure this is possible is by ensuring good communications both in person and otherwise, in this instance the team appointed a Customer Liason (Michael) to be the link between the team and the customer. Ideally the team would have liked to meet the customer more but given the distance they had to travel for each customer meeting from Dumfries and Galloway, this was not feasible, so the team regularly emailed the customer to make them aware of any queries or issues relating to the project.

The team's face-to-face interaction with the customer took place in five meetings: the first was to meet the customer for the first time and gather requirements, the following meetings were to demonstrate the progress made in each iteration. From requirements gathering, the team were elaborated on the project description in order to create user stories, and agreed that over the 7 month period it would be feasible to implement most (if not all) the desired features into the dashboard. One of the team's initial challenges was how to convey our requirements over to the customer who was not particularly technologically literate, but the team did well to come to a mutual understanding over what was expected from both parties.

Over the next few meetings, the customer seemed very pleased by the progress made from each iteration. What was extremely pleasing was how the team identified possible extra features that the customer never initially though about whilst at the same time the customer pointed out areas of our project the team had not previously considered. Generally, meetings were conducted in stages: the first involved the team demonstrating the progress made using the live deployment of the dashboard (this was also useful for them to be able to check our progress outside of meetings and also for their stakeholders to see the progress the team has made); clarify any issues the team was currently facing (i.e. a feature that may not be an ideal solution or is not feasible to implement within the time frame); agree on what is expected for the next iteration/meeting and finally ask the customer for any further feedback/questions they may have.

An issue that arose when interacting with the customer was that despite previously agreeing to implement data access via an API, the team realised half way through the process this may not be feasible due to inconsistent and outdated data; and the lack of helpful documentation provided by relevant government sources. Thankfully the customer recognised this and got the team in touch with the owner of the website the team had previously acquired CSV files from for the graphs on the dashboard. Whilst this was positive to begin with (the team were told data would be updated within 24 hours), this was never carried out by the site owner and thus could not be used for our project. The site's developers did not offer much assistance either and did not get in touch with the team until the customer intervened. Thankfully the team agreed with the customer that using the CSV importer was a practical alternative given the fact that most existing dashboards use CSV files as well, as opposed to dynamically through an API.

A key aspect of the project was the fact that the team not only had to communicate with the customer but also with other project teams. The team was contacted by other teams regarding the possibility of integrating their projects into our dashboard, this was initially agreed however the team agreed with most teams that each project would be as standalone as possible. The team were in regular contact with the project team involved in moving the Crichton's website over to a new platform who would be able to integrate the dashboard into their homepage.

%------------------------------------------------------------------------------
\section{Conclusions}
\label{sec:conclusions}

%Explain the wider lessons that you learned about software engineering,
%based on the specific issues discussed in previous sections.  Reflect
%on the extent to which these lessons could be generalised to other
%types of software project.  Relate the wider lessons to others
%reported in case studies in the software engineering literature.

The Crichton Institute has provided the team a great way to expand our knowledge to software development. The project has provided the team with the chance to work on a complex but satisfying problem. Indeed that project was not simple, it had a lot of requirements from which a great amount of time has been taken for research regarding what implementation choices the team could take, frameworks that had to be discarded and replaced and more problems regarding APIs.

Even though the project was challenging, its positive impact should not be underestimated. Software development is a hard concept to grasp on, due to its nature that makes it need to be done in specific parts, which if ignored could prove disastrous to the end project.

Software development is an iterative process. The iteration consists of planning, implementation, testing and evaluation. Following this phases a software developer  starts by acquiring new requirements for its program, it analyses those requirements and provides and provides a design and implementation for them. Then, those implementations are tested and evaluated which will most probably give new requirements for the project. This iterative methods could prove most beneficial for a developer,since they can significantly cut down the costs ,avoids misunderstandings, finds defects faster, it encourages feedback (both for clients and team members) and proves the credibility of the program or application to its stakeholders.

The iterative design has taught the team some valuables lessons. Firstly, software development never ends, there are always more defects, requirements or better solutions (based on cost or performance) for every project. This lifecycle goes on as long as technologies evolve and this by nature does not end. This proved true for the team since our project was not fully complete even at the end. Things that could be improved consist of adding an API importer which would allow automatic data updates. Also, involving more datasets to the application instead of just Dumfries and Galloway and Scotland wide (e.g. having UK wide data). Furthermore, the team could implement more data visualisations such as pie charts or overlaying graphs, or even some more graphical updates to improve the user experience. In addition to that, the team could improve certain parts such as the PDF exporter (by enabling it to project different graph sizes and bar charts) or the search results (e.g. enabling sorting, or creation of a saved configuration). Lastly the team could deploy the application to a real production server such as NGINX.

%==============================================================================
\bibliographystyle{plain}
\bibliography{dissertation}
\end{document}
